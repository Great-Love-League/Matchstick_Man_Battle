<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的游戏 - Level 2</title>

    <script type="text/javascript">const min = Math.min;</script>

    <!-- 保留旧项目的 jQuery（若其它脚本依赖） -->
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.4.2.min.js" ></script>
    <script type="text/javascript">
    jQuery.noConflict();
    Object.extend = jQuery.extend;
    </script>
    <script src="lib/jquery.svg.min.js"></script>

    <!-- 视觉与容器样式（见步骤三：页面居中） -->
    <style>
        @font-face {
            font-family: "ThaleahFat";
            src: url("./ThaleahFat.ttf") format("truetype");
            font-weight: normal;
            font-style: normal;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f2f5;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        /* 游戏画布的容器（画框）
           容器尺寸将根据内部 canvas 自动调整（通过 JS 监听 canvas 的创建与尺寸变化）
        */
        #game-container {
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            line-height: 0; /* 修复 p5 默认下方空白 */
            background: #ffffff; /* 白色背景作为画布容器 */
            display: inline-block; /* 随内部 canvas 尺寸伸缩 */
            position: relative;
        }

        /* HUD（覆盖在画布上） */
        #hud {
            position: absolute;
            top: 12px;
            right: 12px;
            left: 12px;
            display: flex;
            justify-content: space-between;
            gap: 12px;
            z-index: 50;
            pointer-events: none; /* 让点击穿透到画布 */
        }
        .player-panel {
            pointer-events: auto; /* 面板内可交互（如果需要） */
            background: rgba(0,0,0,0.55);
            color: #fff;
            padding: 8px 12px;
            border-radius: 10px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(4px);
            min-width: 220px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.24);
        }
        .pp-left { justify-content: flex-start; }
        .pp-right { justify-content: flex-end; }
        .avatar { width:40px; height:40px; border-radius:6px; background:linear-gradient(180deg,#333,#111); overflow:hidden; flex:0 0 40px; }
        .avatar img { width:100%; height:100%; object-fit:cover; display:block; }
        .meta { display:flex; flex-direction:column; gap:4px; }
        .meta .name { font-weight:700; font-size:14px; }
        .meta .sub { font-size:12px; opacity:0.9; }
        .hp { display:flex; align-items:center; gap:8px; }
        .bar { width:140px; height:12px; background:rgba(255,255,255,0.12); border-radius:6px; overflow:hidden; }
        .bar .fill { height:100%; background:linear-gradient(90deg,#ff5f6d,#ffc371); width:100%; transition: width 160ms linear; }
        .hp .value { min-width:48px; text-align:right; font-variant-numeric: tabular-nums; }
        .stat { font-weight:600; font-size:12px; }

        /* Stage wrapper glow and animated gradient border (retro palette) */
        #stage-wrapper { position: relative; display: inline-block; border-radius: 14px; padding: 10px; }
        /* animated gradient glow using pseudo-element (retro neon) */
        #stage-wrapper::before {
            content: "";
            position: absolute;
            inset: -8px;
            z-index: 1;
            border-radius: 20px;
            background: conic-gradient(from 0deg, #00ffe1, #ff3db4, #ffd166, #00ffe1);
            filter: blur(14px) saturate(1.3);
            opacity: 0.9;
            pointer-events: none;
            animation: rotateGradient 12s linear infinite;
            mix-blend-mode: screen;
        }
        /* inner subtle frame to make area crisp */
        #stage-wrapper::after {
            content: "";
            position: absolute;
            inset: 0px;
            z-index: 3;
            border-radius: 12px;
            box-shadow: inset 0 0 30px rgba(255,255,255,0.02);
            pointer-events: none;
        }
        @keyframes rotateGradient { to { transform: rotate(360deg); } }

        /* scanline overlay for retro vibe */
        .scanlines { position:absolute; inset:0; z-index:4; pointer-events:none; mix-blend-mode:overlay; background-image: linear-gradient(rgba(255,255,255,0.03) 1px, rgba(0,0,0,0.02) 1px); background-size:100% 4px; opacity:0.55; }

        /* ensure game canvas is above effects but below HUD */
        #game-container { position: relative; z-index: 10; }

        /* 返回按钮样式（保留） */
        .top-controls { text-align: center; margin: 12px 0; position: absolute; top: 12px; width: 100%; left: 0; }
        #back-to-menu { padding:8px 14px; font-size:14px; cursor:pointer; border-radius:6px; background:linear-gradient(90deg,#ff6ec7,#00f0ff); color:#fff; border:none; box-shadow:0 4px 12px rgba(0,0,0,0.25); }

        /* 若页面宽度小于容器，允许横向缩放（基本响应式） */
        @media (max-width: 1000px) {
            #game-container { width: calc(100vw - 40px); height: calc((100vw - 40px) * 2/3); }
        }
    </style>
    <!-- 不在 head 中加载 p5/box2d，改在 body 底部按依赖顺序加载 -->
</head>

<body>
    <div class="top-controls">
        <button id="back-to-menu">返回菜单</button>
    </div>

    <!-- Stage wrapper: 用于放置发光边框与粒子特效 -->
    <div id="stage-wrapper">
        <!-- 发光 / 渐变环通过伪元素实现（CSS） -->
        <!-- 粒子动画层（canvas） -->
        <canvas id="fx-canvas" style="position:absolute;inset:0;width:100%;height:100%;pointer-events:none;z-index:0;display:block;"></canvas>
    <div class="scanlines" aria-hidden="true" style="z-index:4;"></div>
    <div id="fx-flash" aria-hidden="true" style="z-index:6;pointer-events:none;position:absolute;inset:0;opacity:0;transition:opacity 220ms ease;mix-blend-mode:screen;"></div>

        <!-- 这是我们的“画框”/“容器” -->
        <div id="game-container">
        <!-- 若旧代码有 canvas（静态 fallback），我们会把它移动到这里；p5 创建的 canvas 也会被 re-parent 到此容器 -->
        <canvas id="canvas" style="display:block;" height="32" width="32"></canvas>
    <!-- HUD：左右分别展示玩家 0 / 玩家 1 的信息（头像、名字、HP、弹药、分数） -->
        <div id="hud" aria-live="polite">
            <div id="player-0" class="player-panel pp-left" role="region" aria-label="Player 0">
                <div class="avatar"><img id="p0-avatar" src="" alt="P0"></div>
                <div class="meta">
                    <div class="name" id="p0-name">P0</div>
                    <div class="sub hp"><div class="bar"><div class="fill" id="p0-hp-fill" style="width:100%"></div></div><div class="value" id="p0-hp-text">100/100</div></div>
                </div>
                <div style="margin-left:auto; text-align:right; display:flex; flex-direction:column; gap:6px;">
                    <div class="stat">Ammo: <span id="p0-ammo">—</span></div>
                    <div class="stat">Score: <span id="p0-score">—</span></div>
                </div>
            </div>

            <div id="player-1" class="player-panel pp-right" role="region" aria-label="Player 1">
                <div style="display:flex; flex-direction:column; gap:6px; text-align:left;">
                    <div class="stat">Score: <span id="p1-score">—</span></div>
                    <div class="stat">Ammo: <span id="p1-ammo">—</span></div>
                </div>
                <div style="margin-left:12px; text-align:left;" class="meta">
                    <div class="name" id="p1-name">P1</div>
                    <div class="sub hp"><div class="bar"><div class="fill" id="p1-hp-fill" style="width:100%"></div></div><div class="value" id="p1-hp-text">100/100</div></div>
                </div>
                <div class="avatar"><img id="p1-avatar" src="" alt="P1"></div>
            </div>
        </div>
        </div>
    </div>

    <!-- 先加载运行时依赖（CDN），再加载本地构建的游戏脚本 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/p5.min.js"></script>

    <!-- 使用本地 box2d.js（替代被阻止的 CDN 版本） -->
    <script src="./box2d.js"></script>

    <!-- 运行时检测（如果 Box2D 未定义，打印警告） -->
    <script>
        (function(){
            function checkBox2D(){
                if (typeof Box2D === 'undefined') {
                    console.warn('Box2D 未定义：本地 ./box2d.js 可能未正确加载。请检查文件路径或脚本错误。');
                }
            }
            if (document.readyState === 'complete') {
                setTimeout(checkBox2D, 50);
            } else {
                window.addEventListener('load', function(){ setTimeout(checkBox2D, 50); });
            }
        })();
    </script>

    <!-- 游戏构建脚本（可能包含 p5 代码），确保在 p5 之后加载 -->
    <script src="./target/js/release/build/game-level2/game-level2.js"></script>

    <!-- 脚本：返回菜单按钮行为 + 把现有或新创建的 canvas 归位到 #game-container -->
    <script>
        document.getElementById('back-to-menu').addEventListener('click', function() {
            window.location.href = 'index.html';
        });

        // 在页面完全加载后把 canvas 元素移动到容器内，并根据 canvas 实际尺寸调整容器大小。
        // 兼容场景：静态 <canvas id="canvas"> 或 p5 在外部脚本中创建的 canvas。
        (function() {
            var container = document.getElementById('game-container');
            if (!container) return;

            // 把 body 直接子节点的 canvas（若存在）移动进容器
            function moveExistingCanvases() {
                var canvases = Array.prototype.slice.call(document.querySelectorAll('body > canvas'));
                canvases.forEach(function(c) {
                    if (c.parentNode !== container) {
                        container.appendChild(c);
                    }
                });
            }

            // 根据 canvas 的宽高属性（canvas.width / canvas.height）调整容器尺寸
            function fitContainerToCanvas(canvas) {
                if (!canvas) return;
                // prefer canvas.width/height which reflect drawing buffer size
                var w = canvas.width || canvas.clientWidth || canvas.getBoundingClientRect().width;
                var h = canvas.height || canvas.clientHeight || canvas.getBoundingClientRect().height;
                if (w) container.style.width = w + 'px';
                if (h) container.style.height = h + 'px';
            }

            // Observe additions to the container: 当 p5 createCanvas 时，canvas 会被 parent 到 container
            var mo = new MutationObserver(function(mutations) {
                mutations.forEach(function(m) {
                    if (m.type === 'childList' && m.addedNodes.length) {
                        m.addedNodes.forEach(function(node) {
                            if (node.nodeName === 'CANVAS') {
                                // 确保容器大小匹配新 canvas
                                fitContainerToCanvas(node);

                                // 如果浏览器支持 ResizeObserver，监听 canvas 大小变化（例如 p.resizeCanvas）
                                if (window.ResizeObserver) {
                                    var ro = new ResizeObserver(function() { fitContainerToCanvas(node); });
                                    ro.observe(node);
                                }
                            }
                        });
                    }
                });
            });
            mo.observe(container, { childList: true, subtree: false });

            // 也把页面上已存在的 canvas 移入并适配（例如静态 fallback）
            if (document.readyState === 'complete') {
                moveExistingCanvases();
                // 如果已存在 canvas，则适配第一个
                var firstCanvas = container.querySelector('canvas');
                if (firstCanvas) fitContainerToCanvas(firstCanvas);
            } else {
                window.addEventListener('load', function() {
                    moveExistingCanvases();
                    var firstCanvas = container.querySelector('canvas');
                    if (firstCanvas) fitContainerToCanvas(firstCanvas);
                });
            }
        })();
    
                // HUD 更新逻辑：定期从 window.__mmb_get_state() 读取（若存在）并更新显示
                (function() {
                    function safeText(id, v) { var el = document.getElementById(id); if (el) el.textContent = (v===null || v===undefined) ? '—' : v; }
                    function safeImg(id, url, fallback) { var el = document.getElementById(id); if (!el) return; if (url) el.src = url; else if (fallback) el.src = fallback; else el.removeAttribute('src'); }
                    function safeFill(id, pct, textId) { var f = document.getElementById(id); if (f) f.style.width = (pct) + '%'; if (textId) { var t = document.getElementById(textId); if (t) t.textContent = pct + '/100'; } }

                    function updateHUD() {
                        try {
                            var getter = window.__mmb_get_state;
                            var state = undefined;
                            if (typeof getter === 'function') state = getter();
                            else if (window.__mmb_game) {
                                // best-effort fallback
                                var raw = window.__mmb_game;
                                if (raw && raw.particle_list && raw.particle_list.length>0) {
                                    state = { players: [] };
                                    for (var i=0;i<raw.particle_list.length;i++) {
                                        var p = raw.particle_list[i];
                                        var ctrl = p && p.control ? p.control : { health:0 };
                                        state.players.push({ index: p.index, health: ctrl.health, name: (p.name||null) });
                                    }
                                }
                            }

                            if (!state || !state.players) return;

                            // update player 0
                            var p0 = state.players[0] || { health:0, name:'P0', ammo:null, score:null, avatar:null };
                            var hp0 = Math.max(0, Math.min(100, (p0.health===undefined||p0.health===null)?0:p0.health));
                            safeFill('p0-hp-fill', hp0, 'p0-hp-text');
                            safeText('p0-name', p0.name || ('P'+(p0.index===undefined?0:p0.index)));
                            safeText('p0-ammo', (p0.ammo===null||p0.ammo===undefined)?'—':p0.ammo);
                            safeText('p0-score', (p0.score===null||p0.score===undefined)?'—':p0.score);
                            safeImg('p0-avatar', p0.avatar, 'assets/Menu/Buttons/default-avatar.png');

                            // update player 1
                            var p1 = state.players[1] || { health:0, name:'P1', ammo:null, score:null, avatar:null };
                            var hp1 = Math.max(0, Math.min(100, (p1.health===undefined||p1.health===null)?0:p1.health));
                            safeFill('p1-hp-fill', hp1, 'p1-hp-text');
                            safeText('p1-name', p1.name || ('P'+(p1.index===undefined?1:p1.index)));
                            safeText('p1-ammo', (p1.ammo===null||p1.ammo===undefined)?'—':p1.ammo);
                            safeText('p1-score', (p1.score===null||p1.score===undefined)?'—':p1.score);
                            safeImg('p1-avatar', p1.avatar, 'assets/Menu/Buttons/default-avatar.png');

                        } catch (e) {
                            // ignore update errors
                        }
                    }

                    // Poll at 10Hz for smooth but light updates
                    setInterval(updateHUD, 100);
                    setTimeout(updateHUD, 250);
                })();

                // FX: 粒子动画（轻量）
                (function(){
                    var canvas = document.getElementById('fx-canvas');
                    if (!canvas) return;
                    var container = document.getElementById('stage-wrapper');
                    var ctx = canvas.getContext('2d');
                    var dpi = window.devicePixelRatio || 1;
                                var particles = [];
                                // queue for external FX triggers (e.g., hits)
                                if (!window.__mmb_fx_queue) window.__mmb_fx_queue = [];
                                window.__mmb_trigger_hit = function(playerIndex, screenX, screenY, damage) {
                                    try {
                                        window.__mmb_fx_queue.push({ type: 'hit', player: playerIndex, x: screenX, y: screenY, damage: damage });
                                    } catch (e) {}
                                };
                    var running = true;

                    function resize() {
                        var w = container.clientWidth;
                        var h = container.clientHeight;
                        canvas.style.width = w + 'px';
                        canvas.style.height = h + 'px';
                        canvas.width = Math.max(1, Math.floor(w * dpi));
                        canvas.height = Math.max(1, Math.floor(h * dpi));
                        ctx.setTransform(dpi,0,0,dpi,0,0);
                    }

                    function spawn(n) {
                        for (var i=0;i<n;i++) {
                            particles.push({
                                x: Math.random()*container.clientWidth,
                                y: Math.random()*container.clientHeight,
                                vx: (Math.random()-0.5)*0.6,
                                vy: (Math.random()-0.5)*0.6,
                                r: 2 + Math.random()*6,
                                life: 200 + Math.floor(Math.random()*400),
                                alpha: 0.08 + Math.random()*0.18
                            });
                        }
                    }

                    function spawnBurst(x,y,count,color) {
                        for (var i=0;i<count;i++) {
                            var ang = Math.random()*Math.PI*2;
                            var speed = 1 + Math.random()*3;
                            particles.push({ x: x + (Math.random()-0.5)*6, y: y + (Math.random()-0.5)*6, vx: Math.cos(ang)*speed, vy: Math.sin(ang)*speed, r: 1+Math.random()*4, life: 40+Math.floor(Math.random()*60), alpha: 0.3, color: color });
                        }
                    }

                        // 改为晃动整个舞台：根据强度（damage）控制像素偏移与时长
                        function shakeStage(intensity, duration) {
                            try {
                                var el = document.getElementById('stage-wrapper');
                                if (!el) return;
                                var start = performance.now();
                                var rafId = null;
                                // 清除已有的 transform 保证叠加不会累积
                                var prev = el.__shake_prev || '';
                                el.__shake_prev = prev;

                                function tick(now) {
                                    var elapsed = now - start;
                                    var t = elapsed / duration;
                                    if (t >= 1) {
                                        el.style.transform = '';
                                        if (rafId) cancelAnimationFrame(rafId);
                                        return;
                                    }
                                    // 随机抖动，随时间衰减
                                    var damper = 1 - t;
                                    var max = intensity * damper;
                                    var x = (Math.random() * 2 - 1) * max;
                                    var y = (Math.random() * 2 - 1) * max;
                                    var rot = (Math.random() * 2 - 1) * (max * 0.06);
                                    el.style.transform = 'translate(' + x.toFixed(2) + 'px,' + y.toFixed(2) + 'px) rotate(' + rot.toFixed(2) + 'deg)';
                                    rafId = requestAnimationFrame(tick);
                                }
                                rafId = requestAnimationFrame(tick);
                            } catch (e) { /* ignore */ }
                        }

                    function step() {
                        if (!running) return;
                        ctx.clearRect(0,0,canvas.width, canvas.height);
                        ctx.globalCompositeOperation = 'lighter';
                        for (var i=particles.length-1;i>=0;i--) {
                            var p = particles[i];
                            p.x += p.vx;
                            p.y += p.vy;
                            p.life--;
                            p.alpha *= 0.9997;
                            if (p.x < -20) p.x = container.clientWidth + 20;
                            if (p.x > container.clientWidth + 20) p.x = -20;
                            if (p.y < -20) p.y = container.clientHeight + 20;
                            if (p.y > container.clientHeight + 20) p.y = -20;
                            var grd = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r*2);
                            if (p.color) {
                                grd.addColorStop(0, 'rgba('+p.color.r+','+p.color.g+','+p.color.b+','+ (p.alpha*0.9) +')');
                                grd.addColorStop(1, 'rgba('+p.color.r+','+p.color.g+','+p.color.b+',0)');
                            } else {
                                grd.addColorStop(0, 'rgba(255,255,255,'+ (p.alpha*0.9) +')');
                                grd.addColorStop(1, 'rgba(120,80,255,0)');
                            }
                            ctx.fillStyle = grd;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
                            ctx.fill();
                            if (p.life <= 0) particles.splice(i,1);
                        }
                        // process FX queue
                        if (window.__mmb_fx_queue && window.__mmb_fx_queue.length) {
                            while (window.__mmb_fx_queue.length) {
                                var q = window.__mmb_fx_queue.shift();
                                if (q && q.type === 'hit') {
                                    // q.x/q.y expected to be screen coordinates relative to game container
                                    var sx = q.x, sy = q.y;
                                    // clamp
                                    if (typeof sx !== 'number' || typeof sy !== 'number') { sx = container.clientWidth/2; sy = container.clientHeight/2; }
                                    // 改为触发整体晃动（基于伤害），并保留短暂闪白效果；移除原先的粒子爆发（因不明显）
                                    var dmg = q.damage || 10;
                                    // intensity: 像素偏移，duration: 毫秒
                                    var intensity = Math.min(28, 4 + Math.floor(dmg * 0.6));
                                    var duration = Math.min(700, 120 + Math.floor(dmg * 12));
                                    try { shakeStage(intensity, duration); } catch(e) {}
                                    // flash（更短更柔和）
                                    try {
                                        var flash = document.getElementById('fx-flash');
                                        if (flash) {
                                            flash.style.background = 'radial-gradient(circle at '+(sx/container.clientWidth*100).toFixed(1)+'% '+(sy/container.clientHeight*100).toFixed(1)+'%, rgba(255,220,200,0.28), rgba(255,60,140,0.06) 36%, rgba(0,0,0,0) 56%)';
                                            flash.style.opacity = 0.72;
                                            setTimeout(function(){ flash.style.opacity = 0; }, Math.min(240, Math.max(120, Math.floor(duration*0.28))));
                                        }
                                    } catch (e) {}
                                }
                            }
                        }
                        // keep density constant
                        if (particles.length < 36) spawn(6);
                        requestAnimationFrame(step);
                    }

                    window.addEventListener('resize', function(){ resize(); });
                    // ensure initial layout ready
                    setTimeout(function(){ resize(); spawn(36); requestAnimationFrame(step); }, 200);
                })();
    </script>
</body>

</html>